Here is a complete list of what functions are available to the lua environment.
If nothing else is specified, they exhibit the same semantics as their lua counterpart.

Implemented in Java
-------------------
getfenv(f)
	returns the environment for function f
	f must be a lua function or an integer describing the stack level,
	much like in real lua

setfenv(f, env)
	   sets the environment of f to env
	   f must be a lua function and env must be a lua table
	   returns f

pcall(f, ...)
	 calls f with ... as args
	 if f throws an error, pcall catches it and returns:
	 	 false, error message, stack trace, exception object
	 and if it succeeds:
	 	true, [original return values from f]
	 The stack trace is a concatenation of stack trace lines, where each line is on the form:
	 "at <sourcefile>:<linenumber>\n" and the exception object is the java exception that originally threw the exception.


error(msg)
	throws an error (a LuaException) with the error message msg

collectgarbage([option])
	if option is nil, "step" or "collect", this performs a full garbage collect
	if option is "count", this returns used memory, free memory and total memory in KB


rawequal
rawset
rawget	
select
unpack
next
type
getmetatable
setmetatable
tostring
tonumber
print
string.char
string.byte
string.sub
string.lower
string.upper
string.reverse
math.*
coroutine.*
table.concat (as tableconcat)

Implemented in stdlib.lua
------------------
assert
ipairs
pairs
string.len
string.rep
table.insert
table.remove
table.maxn
table.getn
table.setn
coroutine.wrap

In progress
-----------
string.find
string.match
string.format

Not implemented
---------------
dofile
load
loadfile
loadstring
xpcall

module
require
package.*

string.dump
string.gmatch
string.gsub

table.sort

io.*
os.*
debug.*

